# Защита данных от потери

## Механизмы защиты данных

### 1. CREATE TABLE IF NOT EXISTS
- ✅ **Безопасно**: не удаляет существующие данные
- ✅ **Идемпотентно**: можно запускать многократно
- ✅ **Проверено**: тест показал, что данные сохраняются

### 2. WAL режим (Write-Ahead Logging)
- ✅ Защищает от потери данных при сбоях
- ✅ Изменения записываются в журнал перед применением
- ✅ При сбое данные восстанавливаются автоматически

### 3. Транзакции и commit
- ✅ Данные сохраняются только после `commit()`
- ✅ При сбое до `commit()` изменения откатываются
- ✅ Атомарность операций гарантирована

### 4. Архитектура worker.py
- ✅ Статус задачи сохраняется ДО начала парсинга
- ✅ Соединение с БД закрывается перед долгим парсингом
- ✅ При зависании задача остаётся в очереди

## Что происходит при зависании

### Сценарий 1: Зависание при парсинге
1. Статус "processing" уже сохранён в БД ✅
2. Парсинг зависает
3. При перезапуске: задача найдётся со статусом "processing"
4. Можно обработать заново или пометить как "error"

### Сценарий 2: Зависание до сохранения результатов
1. Парсинг завершён, но результаты не сохранены
2. Задача остаётся в очереди со статусом "processing"
3. При перезапуске: парсинг повторится
4. Данные не потеряются (задача в БД)

## Рекомендации

### Для обработки зависших задач:
```python
# В worker.py можно добавить:
# 1. Проверку задач со статусом "processing" старше 30 минут
# 2. Автоматический сброс статуса на "pending" для повторной обработки
# 3. Логирование зависших задач
```

### Для дополнительной защиты:
1. Регулярные бэкапы БД (уже есть в `safe_db_utils.py`)
2. Мониторинг статусов задач
3. Уведомления о зависших задачах

## Итог

✅ **Данные защищены**: 
- CREATE TABLE IF NOT EXISTS не удаляет данные
- WAL режим защищает от сбоев
- Транзакции гарантируют атомарность
- Задачи остаются в очереди даже при зависании

✅ **При зависании**:
- Задача не теряется (остаётся в БД)
- Можно обработать заново при перезапуске
- Статус задачи сохраняется

